---
layout: post
title: FZF を使ってみる
excerpt:
date: 2018-12-13
tags: command
author: 五穀豊穣
---

# FZF を導入する

peco と並ぶインタラクティブフィルター。

```zsh:.zshrc

[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
export FZF_DEFAULT_COMMAND='rg --files --hidden --glob "!.git"'
export FZF_DEFAULT_OPTS='
--color fg:188,bg:233,hl:103,fg+:222,bg+:234,hl+:104
--color info:183,prompt:110,spinner:107,pointer:167,marker:215
'
```

```zsh:.fzf.zsh

# c - browse chrome history
c() {
  local cols sep google_history open
  cols=$(( COLUMNS / 3 ))
  sep='{::}'

  if [ "$(uname)" = "Darwin" ]; then
    google_history="$HOME/Library/Application Support/Google/Chrome/Default/History"
    open=open
  else
    google_history="$HOME/.config/google-chrome/Default/History"
    open=xdg-open
  fi
  cp -f "$google_history" /tmp/h
  sqlite3 -separator $sep /tmp/h \
    "select substr(title, 1, $cols), url
     from urls order by last_visit_time desc" |
  awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}' |
  fzf --ansi --multi | sed 's#.*\(https*://\)#\1#' | xargs $open > /dev/null 2> /dev/null
}

select-history() {
    BUFFER=$(history 1 | sort -k1,1nr | perl -ne 'BEGIN { my @lines = (); } s/^\s*\d+\s*//; $in=$_; if (!(grep {$in eq $_} @lines)) { push(@lines, $in); print $in; }' | fzf --no-sort +m --query "$LBUFFER" --prompt="History > ")
    CURSOR=$#BUFFER
}

zle -N select-history
bindkey '^r' select-history
```

c は Chrome の履歴から URL をとってきて、ブラウザで表示するもの。
複数選択できる。

select-history は履歴のインクリメントサーチ。
C-r で起動する。

@startuml
start
:変数 cols sep google_history open;
:cols = ターミナルの幅 /3;
:google_history = 履歴ファイルパス;
:open = open コマンド;
:/tmp/h に履歴ファイルをコピー
:sqlite3 にクエリを投げる
結果を awk で整形して fzf で選択
選択した結果を sed で整形して引数として open コマンドに投げる;
end
@enduml

---

Google Chrome の履歴が sqlite3 のファイルだったのか。

### sqlite3 で取得するデータ

```zsh
$ sqlite3 -separator '{::}' /tmp/h
sqlite>
```

セパレータはデータの区切り文字。ここでは title と url を並べて出力するのでそれの間を区切る文字を{::} にしたということか。

テーブルがいくつもある。

```sqlite
sqlite>.table
downloads                meta                     urls
downloads_slices         segment_usage            visit_source
downloads_url_chains     segments                 visits
keyword_search_terms     typed_url_sync_metadat
```

この中で urls が履歴の URL らしい。
スキーマを見ると

```sqlite
CREATE TABLE urls(id INTEGER PRIMARY KEY AUTOINCREMENT,url LONGVARCHAR,title LONGVARCHAR,visit_count INTEGER DEFAULT 0 NOT NULL,typed_count INTEGER DEFAULT 0 NOT NULL,last_visit_time INTEGER NOT NULL,hidden INTEGER DEFAULT 0 NOT NULL);
CREATE INDEX urls_url_index ON urls (url);
```

url と title と last_visit_time を使ってクエリを組んでいる。
title は substr 関数で取得している。

```sqlite
substr(文字列, 開始位置, 文字長)
```

発行クエリは

```sqlite
sqlite> select substr(title, 1, 33), url from urls order by last_visit_time desc;
```

### awk で加工する

テスト用に sqlite3 から 5 行だけ取得する。

```zsh
sqlite3 -separator '{::}' /tmp/h "select substr(title, 1, 33), url from urls order by last_visit_time desc limit 5" | awk -F '{::}' '{printf "%-33s \x1b[36m%s\x1b[m\n", $1 $2}'
```

awk の -F (fs) でセパレータを指定してフォーマット。
%-33s は 33 文字で左詰め、日本語はあまり整わないのかな。

fzf の --multi は TAB or C-i で複数選択

```zsh
...| sed 's#.*\(https*://\)#\1#'
```

#は ruby のように @ @ @ とかのようにスラッシュでないセパレータを使っているだけ。
\(hoge\) で部分マッチしたものを \1 \2 ...で再利用して全文上書きしている。

argxs で複数の引数を渡す。
素晴らしい。

---

#
